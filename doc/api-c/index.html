<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>sphlib: sphlib C code documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">sphlib</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>sphlib C code documentation </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="overview"></a>
Overview</h2>
<p><code>sphlib</code> is a library which contains implementations of various cryptographic hash functions. These pages have been generated with <a href="http://www.doxygen.org/index.html">doxygen</a> and document the API for the C implementations.</p>
<p>The API is described in appropriate header files, which are available in the "Files" section. Each hash function family has its own header, whose name begins with <code>"sph_"</code> and contains the family name. For instance, the API for the RIPEMD hash functions is available in the header file <code><a class="el" href="sph__ripemd_8h.html">sph_ripemd.h</a></code>.</p>
<h2><a class="anchor" id="principles"></a>
API structure and conventions</h2>
<h3><a class="anchor" id="io"></a>
Input/output conventions</h3>
<p>In all generality, hash functions operate over strings of bits. Individual bits are rarely encountered in C programming or actual communication protocols; most protocols converge on the ubiquitous "octet" which is a group of eight bits. Data is thus expressed as a stream of octets. The C programming language contains the notion of a "byte", which is a data unit managed under the type <code>"unsigned
 char"</code>. The C standard prescribes that a byte should hold at least eight bits, but possibly more. Most modern architectures, even in the embedded world, feature eight-bit bytes, i.e. map bytes to octets.</p>
<p>Nevertheless, for some of the implemented hash functions, an extra API has been added, which allows the input of arbitrary sequences of bits: when the computation is about to be closed, 1 to 7 extra bits can be added. The functions for which this API is implemented include the SHA-2 functions and all SHA-3 candidates.</p>
<p><code>sphlib</code> defines hash function which may hash octet streams, i.e. streams of bits where the number of bits is a multiple of eight. The data input functions in the <code>sphlib</code> API expect data as anonymous pointers (<code>"const void *"</code>) with a length (of type <code>"size_t"</code>) which gives the input data chunk length in bytes. A byte is assumed to be an octet; the <code><a class="el" href="sph__types_8h.html">sph_types.h</a></code> header contains a compile-time test which prevents compilation on architectures where this property is not met.</p>
<p>The hash function output is also converted into bytes. All currently implemented hash functions have an output width which is a multiple of eight, and this is likely to remain true for new designs.</p>
<p>Most hash functions internally convert input data into 32-bit of 64-bit words, using either little-endian or big-endian conversion. The hash output also often consists of such words, which are encoded into output bytes with a similar endianness convention. Some hash functions have been only loosely specified on that subject; when necessary, <code>sphlib</code> has been tested against published "reference" implementations in order to use the same conventions.</p>
<h3><a class="anchor" id="shortname"></a>
Function short name</h3>
<p>Each implemented hash function has a "short name" which is used internally to derive the identifiers for the functions and context structures which the function uses. For instance, MD5 has the short name <code>"md5"</code>. Short names are listed in the next section, for the implemented hash functions. In subsequent sections, the short name will be assumed to be <code>"XXX"</code>: replace with the actual hash function name to get the C identifier.</p>
<p>Note: some functions within the same family share the same core elements, such as update function or context structure. Correspondingly, some of the defined types or functions may actually be macros which transparently evaluate to another type or function name.</p>
<h3><a class="anchor" id="context"></a>
Context structure</h3>
<p>Each implemented hash fonction has its own context structure, available under the type name <code>"sph_XXX_context"</code> for the hash function with short name <code>"XXX"</code>. This structure holds all needed state for a running hash computation.</p>
<p>The contents of these structures are meant to be opaque, and private to the implementation. However, these contents are specified in the header files so that application code which uses <code>sphlib</code> may access the size of those structures.</p>
<p>The caller is responsible for allocating the context structure, whether by dynamic allocation (<code>malloc()</code> or equivalent), static allocation (a global permanent variable), as an automatic variable ("on the stack"), or by any other mean which ensures proper structure alignment. <code>sphlib</code> code performs no dynamic allocation by itself.</p>
<p>The context must be initialized before use, using the <code>sph_XXX_init()</code> function. This function sets the context state to proper initial values for hashing.</p>
<p>Since all state data is contained within the context structure, <code>sphlib</code> is thread-safe and reentrant: several hash computations may be performed in parallel, provided that they do not operate on the same context. Moreover, a running computation can be cloned by copying the context (with a simple <code>memcpy()</code>): the context and its clone are then independant and may be updated with new data and/or closed without interfering with each other. Similarly, a context structure can be moved in memory at will: context structures contain no pointer, in particular no pointer to themselves.</p>
<h3><a class="anchor" id="dataio"></a>
Data input</h3>
<p>Hashed data is input with the <code>sph_XXX()</code> fonction, which takes as parameters a pointer to the context, a pointer to the data to hash, and the number of data bytes to hash. The context is updated with the new data.</p>
<p>Data can be input in one or several calls, with arbitrary input lengths. However, it is best, performance wise, to input data by relatively big chunks (say a few kilobytes), because this allows <code>sphlib</code> to optimize things and avoid internal copying.</p>
<p>When all data has been input, the context can be closed with <code>sph_XXX_close()</code>. The hash output is computed and written into the provided buffer. The caller must take care to provide a buffer of appropriate length; e.g., when using SHA-1, the output is a 20-byte word, therefore the output buffer must be at least 20-byte long.</p>
<p>For some hash functions, the <code>sph_XXX_addbits_and_close()</code> function can be used instead of <code>sph_XXX_close()</code>. This function can take a few extra <b>bits</b> to be added at the end of the input message. This allows hashing messages with a bit length which is not a multiple of 8. The extra bits are provided as an unsigned integer value, and a bit count. The bit count must be between 0 and 7, inclusive. The extra bits are provided as bits 7 to 0 (bits of numerical value 128, 64, 32... downto 0), in that order. For instance, to add three bits of value 1, 1 and 0, the unsigned integer will have value 192 (1*128 + 1*64 + 0*32) and the bit count will be 3.</p>
<p>The <code>SPH_SIZE_XXX</code> macro is defined for each hash function; it evaluates to the function output size, expressed in bits. For instance, <code>SPH_SIZE_sha1</code> evaluates to <code>160</code>.</p>
<p>When closed, the context is automatically reinitialized and can be immediately used for another computation. It is not necessary to call <code>sph_XXX_init()</code> after a close. Note that <code>sph_XXX_init()</code> can still be called to "reset" a context, i.e. forget previously input data, and get back to the initial state.</p>
<h3><a class="anchor" id="alignment"></a>
Data alignment</h3>
<p>"Alignment" is a property of data, which is said to be "properly
 aligned" when its emplacement in memory is such that the data can be optimally read by full words. This depends on the type of access; basically, some hash functions will read data by 32-bit or 64-bit words. <code>sphlib</code> does not mandate such alignment for input data, but using aligned data can substantially improve performance.</p>
<p>As a rule, it is best to input data by chunks whose length (in bytes) is a multiple of eight, and which begins at "generally aligned" addresses, such as the base address returned by a call to <code>malloc()</code>.</p>
<h2><a class="anchor" id="functions"></a>
Implemented functions</h2>
<p>We give here the list of implemented functions. They are grouped by family; to each family corresponds a specific header file. Each individual function has its associated "short name". Please refer to the documentation for that header file to get details on the hash function denomination and provenance.</p>
<p>Note: the functions marked with a '(64)' in the list below are available only if the C compiler provides an integer type of length 64 bits or more. Such a type is mandatory in the latest C standard (ISO 9899:1999, aka "C99") and is present in several older compilers as well, so chances are that such a type is available.</p>
<ul>
<li>HAVAL family: file <code><a class="el" href="sph__haval_8h.html">sph_haval.h</a></code><ul>
<li>HAVAL-128/3 (128-bit, 3 passes): short name: <code>haval128_3</code></li>
<li>HAVAL-128/4 (128-bit, 4 passes): short name: <code>haval128_4</code></li>
<li>HAVAL-128/5 (128-bit, 5 passes): short name: <code>haval128_5</code></li>
<li>HAVAL-160/3 (160-bit, 3 passes): short name: <code>haval160_3</code></li>
<li>HAVAL-160/4 (160-bit, 4 passes): short name: <code>haval160_4</code></li>
<li>HAVAL-160/5 (160-bit, 5 passes): short name: <code>haval160_5</code></li>
<li>HAVAL-192/3 (192-bit, 3 passes): short name: <code>haval192_3</code></li>
<li>HAVAL-192/4 (192-bit, 4 passes): short name: <code>haval192_4</code></li>
<li>HAVAL-192/5 (192-bit, 5 passes): short name: <code>haval192_5</code></li>
<li>HAVAL-224/3 (224-bit, 3 passes): short name: <code>haval224_3</code></li>
<li>HAVAL-224/4 (224-bit, 4 passes): short name: <code>haval224_4</code></li>
<li>HAVAL-224/5 (224-bit, 5 passes): short name: <code>haval224_5</code></li>
<li>HAVAL-256/3 (256-bit, 3 passes): short name: <code>haval256_3</code></li>
<li>HAVAL-256/4 (256-bit, 4 passes): short name: <code>haval256_4</code></li>
<li>HAVAL-256/5 (256-bit, 5 passes): short name: <code>haval256_5</code></li>
</ul>
</li>
<li>MD2: file <code><a class="el" href="sph__md2_8h.html">sph_md2.h</a></code>, short name: <code>md2</code></li>
<li>MD4: file <code><a class="el" href="sph__md4_8h.html">sph_md4.h</a></code>, short name: <code>md4</code></li>
<li>MD5: file <code><a class="el" href="sph__md5_8h.html">sph_md5.h</a></code>, short name: <code>md5</code></li>
<li>PANAMA: file <code><a class="el" href="sph__panama_8h.html">sph_panama.h</a></code>, short name: <code>panama</code></li>
<li>RadioGatun family: file <code><a class="el" href="sph__radiogatun_8h.html">sph_radiogatun.h</a></code><ul>
<li>RadioGatun[32]: short name: <code>radiogatun32</code></li>
<li>RadioGatun[64]: short name: <code>radiogatun64</code> (64)</li>
</ul>
</li>
<li>RIPEMD family: file <code><a class="el" href="sph__ripemd_8h.html">sph_ripemd.h</a></code><ul>
<li>RIPEMD: short name: <code>ripemd</code></li>
<li>RIPEMD-128: short name: <code>ripemd128</code></li>
<li>RIPEMD-160: short name: <code>ripemd160</code></li>
</ul>
</li>
<li>SHA-0: file <code><a class="el" href="sph__sha0_8h.html">sph_sha0.h</a></code>, short name: <code>sha0</code></li>
<li>SHA-1: file <code><a class="el" href="sph__sha1_8h.html">sph_sha1.h</a></code>, short name: <code>sha1</code></li>
<li>SHA-2 family, 32-bit hashes: file <code><a class="el" href="sph__sha2_8h.html">sph_sha2.h</a></code><ul>
<li>SHA-224: short name: <code>sha224</code></li>
<li>SHA-256: short name: <code>sha256</code></li>
<li>SHA-384: short name: <code>sha384</code> (64)</li>
<li>SHA-512: short name: <code>sha512</code> (64)</li>
</ul>
</li>
<li>Tiger family: file <code><a class="el" href="sph__tiger_8h.html">sph_tiger.h</a></code><ul>
<li>Tiger: short name: <code>tiger</code> (64)</li>
<li>Tiger2: short name: <code>tiger2</code> (64)</li>
</ul>
</li>
<li>WHIRLPOOL family: file <code><a class="el" href="sph__whirlpool_8h.html">sph_whirlpool.h</a></code><ul>
<li>WHIRLPOOL-0: short name: <code>whirlpool0</code> (64)</li>
<li>WHIRLPOOL-1: short name: <code>whirlpool1</code> (64)</li>
<li>WHIRLPOOL: short name: <code>whirlpool</code> (64)</li>
</ul>
</li>
</ul>
<p>The fourteen second-round SHA-3 candidates are also implemented; when applicable, the implementations follow the "final" specifications as published for the third round of the SHA-3 competition (BLAKE, Groestl, JH, Keccak and Skein have been tweaked for third round).</p>
<ul>
<li>BLAKE family: file <code><a class="el" href="sph__blake_8h.html">sph_blake.h</a></code><ul>
<li>BLAKE-224: short name: <code>blake224</code></li>
<li>BLAKE-256: short name: <code>blake256</code></li>
<li>BLAKE-384: short name: <code>blake384</code></li>
<li>BLAKE-512: short name: <code>blake512</code></li>
</ul>
</li>
<li>BMW (Blue Midnight Wish) family: file <code><a class="el" href="sph__bmw_8h.html">sph_bmw.h</a></code><ul>
<li>BMW-224: short name: <code>bmw224</code></li>
<li>BMW-256: short name: <code>bmw256</code></li>
<li>BMW-384: short name: <code>bmw384</code> (64)</li>
<li>BMW-512: short name: <code>bmw512</code> (64)</li>
</ul>
</li>
<li>CubeHash family: file <code><a class="el" href="sph__cubehash_8h.html">sph_cubehash.h</a></code> (specified as CubeHash16/32 in the CubeHash specification)<ul>
<li>CubeHash-224: short name: <code>cubehash224</code></li>
<li>CubeHash-256: short name: <code>cubehash256</code></li>
<li>CubeHash-384: short name: <code>cubehash384</code></li>
<li>CubeHash-512: short name: <code>cubehash512</code></li>
</ul>
</li>
<li>ECHO family: file <code><a class="el" href="sph__echo_8h.html">sph_echo.h</a></code><ul>
<li>ECHO-224: short name: <code>echo224</code></li>
<li>ECHO-256: short name: <code>echo256</code></li>
<li>ECHO-384: short name: <code>echo384</code></li>
<li>ECHO-512: short name: <code>echo512</code></li>
</ul>
</li>
<li>Fugue family: file <code><a class="el" href="sph__fugue_8h.html">sph_fugue.h</a></code><ul>
<li>Fugue-224: short name: <code>fugue224</code></li>
<li>Fugue-256: short name: <code>fugue256</code></li>
<li>Fugue-384: short name: <code>fugue384</code></li>
<li>Fugue-512: short name: <code>fugue512</code></li>
</ul>
</li>
<li>Groestl family: file <code><a class="el" href="sph__groestl_8h.html">sph_groestl.h</a></code><ul>
<li>Groestl-224: short name: <code>groestl224</code></li>
<li>Groestl-256: short name: <code>groestl256</code></li>
<li>Groestl-384: short name: <code>groestl384</code></li>
<li>Groestl-512: short name: <code>groestl512</code></li>
</ul>
</li>
<li>Hamsi family: file <code><a class="el" href="sph__hamsi_8h.html">sph_hamsi.h</a></code><ul>
<li>Hamsi-224: short name: <code>hamsi224</code></li>
<li>Hamsi-256: short name: <code>hamsi256</code></li>
<li>Hamsi-384: short name: <code>hamsi384</code></li>
<li>Hamsi-512: short name: <code>hamsi512</code></li>
</ul>
</li>
<li>JH family: file <code><a class="el" href="sph__jh_8h.html">sph_jh.h</a></code><ul>
<li>JH-224: short name: <code>jh224</code></li>
<li>JH-256: short name: <code>jh256</code></li>
<li>JH-384: short name: <code>jh384</code></li>
<li>JH-512: short name: <code>jh512</code></li>
</ul>
</li>
<li>Keccak family: file <code><a class="el" href="sph__keccak_8h.html">sph_keccak.h</a></code><ul>
<li>Keccak-224: short name: <code>keccak224</code></li>
<li>Keccak-256: short name: <code>keccak256</code></li>
<li>Keccak-384: short name: <code>keccak384</code></li>
<li>Keccak-512: short name: <code>keccak512</code></li>
</ul>
</li>
<li>Luffa family: file <code><a class="el" href="sph__luffa_8h.html">sph_luffa.h</a></code><ul>
<li>Luffa-224: short name: <code>luffa224</code></li>
<li>Luffa-256: short name: <code>luffa256</code></li>
<li>Luffa-384: short name: <code>luffa384</code></li>
<li>Luffa-512: short name: <code>luffa512</code></li>
</ul>
</li>
<li>Shabal family: file <code><a class="el" href="sph__shabal_8h.html">sph_shabal.h</a></code><ul>
<li>Shabal-192: short name: <code>shabal192</code></li>
<li>Shabal-224: short name: <code>shabal224</code></li>
<li>Shabal-256: short name: <code>shabal256</code></li>
<li>Shabal-384: short name: <code>shabal384</code></li>
<li>Shabal-512: short name: <code>shabal512</code></li>
</ul>
</li>
<li>SHAvite-3 family: file <code><a class="el" href="sph__shavite_8h.html">sph_shavite.h</a></code><ul>
<li>SHAvite-224 (nominally "SHAvite-3 with 224-bit output"): short name: <code>shabal224</code></li>
<li>SHAvite-256 (nominally "SHAvite-3 with 256-bit output"): short name: <code>shabal256</code></li>
<li>SHAvite-384 (nominally "SHAvite-3 with 384-bit output"): short name: <code>shabal384</code></li>
<li>SHAvite-512 (nominally "SHAvite-3 with 512-bit output"): short name: <code>shabal512</code></li>
</ul>
</li>
<li>SIMD family: file <code><a class="el" href="sph__simd_8h.html">sph_simd.h</a></code><ul>
<li>SIMD-224: short name: <code>simd224</code></li>
<li>SIMD-256: short name: <code>simd256</code></li>
<li>SIMD-384: short name: <code>simd384</code></li>
<li>SIMD-512: short name: <code>simd512</code></li>
</ul>
</li>
<li>Skein family: file <code><a class="el" href="sph__skein_8h.html">sph_skein.h</a></code><ul>
<li>Skein-224 (nominally specified as Skein-512-224): short name: <code>skein224</code> (64)</li>
<li>Skein-256 (nominally specified as Skein-512-256): short name: <code>skein256</code> (64)</li>
<li>Skein-384 (nominally specified as Skein-512-384): short name: <code>skein384</code> (64)</li>
<li>Skein-512 (nominally specified as Skein-512-512): short name: <code>skein512</code> (64)</li>
</ul>
</li>
</ul>
<p>For the second-round SHA-3 candidates, the functions are as specified for round 2, i.e. with the "tweaks" that some candidates added between round 1 and round 2; for the five functions which made it to third round, the additional tweaks for round 3 have also been included. Also, some of the submitted packages for round 2 contained errors, in the specification, reference code, or both. <code>sphlib</code> implements the corrected versions. </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Jul 20 2011 21:15:29 for sphlib by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
