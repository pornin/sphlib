<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>sphlib: sph_haval.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">sphlib</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>sph_haval.h File Reference</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="sph__types_8h_source.html">sph_types.h</a>&quot;</code><br/>
</div>
<p><a href="sph__haval_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsph__haval__context.html">sph_haval_context</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a6566ab1af5e33159dfbddc5bddec87a6">SPH_SIZE_haval128_3</a>&#160;&#160;&#160;128</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a87614e72d35880a2e45989f7dc08fdb7">SPH_SIZE_haval128_4</a>&#160;&#160;&#160;128</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ab58f3bb53ab00944e47e06d5f5965e74">SPH_SIZE_haval128_5</a>&#160;&#160;&#160;128</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#aaf27d1e974d0054cba6089f69fe04e8e">SPH_SIZE_haval160_3</a>&#160;&#160;&#160;160</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#afdafbffe5efbbb9cb8fee4168e54906c">SPH_SIZE_haval160_4</a>&#160;&#160;&#160;160</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ae46fa31ac7c2233d259d60aa1bd0a32b">SPH_SIZE_haval160_5</a>&#160;&#160;&#160;160</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a7d38ae85191334b4b823d727b1178310">SPH_SIZE_haval192_3</a>&#160;&#160;&#160;192</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ab2eb2674346d14adfb68c5298d91e9d0">SPH_SIZE_haval192_4</a>&#160;&#160;&#160;192</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a4cca5a9b360f4260ef519443f4b7e8ed">SPH_SIZE_haval192_5</a>&#160;&#160;&#160;192</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ac699591e932ae4ce9edc76e4c2a877e6">SPH_SIZE_haval224_3</a>&#160;&#160;&#160;224</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#adf84e49d2af75c297895838b0777bc32">SPH_SIZE_haval224_4</a>&#160;&#160;&#160;224</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a5089a8a5b5268e001fb1bad4ba586581">SPH_SIZE_haval224_5</a>&#160;&#160;&#160;224</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a92f4819107a3ecd3f2bebc80738da480">SPH_SIZE_haval256_3</a>&#160;&#160;&#160;256</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a153340daffab6e964d7564a5f47a020f">SPH_SIZE_haval256_4</a>&#160;&#160;&#160;256</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ab378eac8c78a9d217704a8479158c13a">SPH_SIZE_haval256_5</a>&#160;&#160;&#160;256</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#af367124146a73bbb4beaf880c68d6a2d">sph_haval128_3_context</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#aa65646bf0d6291f7549ed49532c0859c">sph_haval128_4_context</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#aef6d1a93f1cae0ef525081b25a841f69">sph_haval128_5_context</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ae3e415cef1b3a3cf6d4a10cdef5fc21b">sph_haval160_3_context</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ac49122e7de97c791c9e618da4a9b892f">sph_haval160_4_context</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#af7ab4a92a5f616b9d3ddb4f1bb4706fe">sph_haval160_5_context</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ad76e94e6ecea41ca308131287abbd453">sph_haval192_3_context</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a8d921ce5963297db828c2e2a85160c35">sph_haval192_4_context</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a4d61ca87df88ffe88c59b86d73f94023">sph_haval192_5_context</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#acf1157e57cd3f8bbf25699c93f5053da">sph_haval224_3_context</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#adb69bded14cbe206a30d08271f9352fa">sph_haval224_4_context</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a37ade660f7ea30400190a212ff4e60b1">sph_haval224_5_context</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a8f7de869146cdf91a000551231001617">sph_haval256_3_context</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a86e47b7bbd76965eacb6a2a30fe8248f">sph_haval256_4_context</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a0fbdc7e162f9832877ffd7d5810ff21b">sph_haval256_5_context</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a97bfc1e9d048d1f6e5505527a32f53bc">sph_haval128_3_init</a> (void *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a0c223fedfa18fe2be493e4f276b5aede">sph_haval128_3</a> (void *cc, const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#aaed1b0fb5f5b2f98c3f5179501de8e7d">sph_haval128_3_close</a> (void *cc, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ab28b8ad206a96c058d088ecee9355857">sph_haval128_3_addbits_and_close</a> (void *cc, unsigned ub, unsigned n, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a0aa4226a1579ac5a2767ccbe59b340fa">sph_haval128_4_init</a> (void *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#abee769c1fc556562430acd9e311ad578">sph_haval128_4</a> (void *cc, const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a619d9195ff1f1ebbff30aa6dd325d211">sph_haval128_4_close</a> (void *cc, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a9080af3e8eb5475ffcacbcaf8053b744">sph_haval128_4_addbits_and_close</a> (void *cc, unsigned ub, unsigned n, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#adb1c53f44839654b11470c946a1c65a8">sph_haval128_5_init</a> (void *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#aed8b2c71702ce555d6314ef8a4bd275f">sph_haval128_5</a> (void *cc, const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ad0cb97e02f9b5299c045b8347fdfac97">sph_haval128_5_close</a> (void *cc, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a785b6bef2e1554f056eca3b436f89369">sph_haval128_5_addbits_and_close</a> (void *cc, unsigned ub, unsigned n, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a2fcc401332f79b125c581d3c90bda14d">sph_haval160_3_init</a> (void *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a7f4624148dcb39a5525d0567ceb97e02">sph_haval160_3</a> (void *cc, const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a6600bef16e1c9b36cc7791c80b595a6b">sph_haval160_3_close</a> (void *cc, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a2fd12367e784029b77198cf4525334dc">sph_haval160_3_addbits_and_close</a> (void *cc, unsigned ub, unsigned n, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a2a817499926eb781d2a576c2a883a1aa">sph_haval160_4_init</a> (void *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a5875ec97daa77c5f3c8c4781abccf086">sph_haval160_4</a> (void *cc, const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a36b5108446181627136e96d5d6753e61">sph_haval160_4_close</a> (void *cc, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a5aa0b40d3f6c5445348796aa26b06111">sph_haval160_5_init</a> (void *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a75c1ea042c2aaa29396292870723274d">sph_haval160_5</a> (void *cc, const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a44c89f408a258d46fbb5c4a8183e0c78">sph_haval160_5_close</a> (void *cc, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#acac70255293c678ab1105b563c1cb8d9">sph_haval160_5_addbits_and_close</a> (void *cc, unsigned ub, unsigned n, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a4bb8e4b4a023767c3b94acec84007d73">sph_haval192_3_init</a> (void *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a596fe2cec90956f667679079fc04b9c3">sph_haval192_3</a> (void *cc, const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a238cc6ff3ce791456fbe0b5557cc383f">sph_haval192_3_close</a> (void *cc, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a0c556aef11bb380ec28656a94b5f4605">sph_haval192_3_addbits_and_close</a> (void *cc, unsigned ub, unsigned n, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a5b36e600635b9cd4c1e04d7fa7d9605d">sph_haval192_4_init</a> (void *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a4f40969f0baaec457a9a01c1cb11af8c">sph_haval192_4</a> (void *cc, const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#aad68d957b663970e4b3897aa05eac28c">sph_haval192_4_close</a> (void *cc, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a5b2b42f14cb67f29c77ee29794fe02a6">sph_haval192_4_addbits_and_close</a> (void *cc, unsigned ub, unsigned n, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a6a76545063eca775308ff9b57b59ed24">sph_haval192_5_init</a> (void *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#aa01935e7084dbb281ac6ee30f1321ca4">sph_haval192_5</a> (void *cc, const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ad4a98c330ac620702ff0862e2381a6ff">sph_haval192_5_close</a> (void *cc, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#aaa004124bd3188f03633b8b701b08a3b">sph_haval192_5_addbits_and_close</a> (void *cc, unsigned ub, unsigned n, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ae7538ce2f51535aaa724f6c365f328c8">sph_haval224_3_init</a> (void *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a51e48bd1d3ecbf79248712e3dd959494">sph_haval224_3</a> (void *cc, const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ab86f7b2e9b8b0443b4997015ce600af3">sph_haval224_3_close</a> (void *cc, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#aab0baf31e736678bb3482ea927ab654e">sph_haval224_3_addbits_and_close</a> (void *cc, unsigned ub, unsigned n, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a67edea48177c1abf83f14a1fae0b202d">sph_haval224_4_init</a> (void *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a9b1250c04a76ab0909c87f1addcf6bcb">sph_haval224_4</a> (void *cc, const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a1300486b4bbbdea2f5689d3ce93ef6ef">sph_haval224_4_close</a> (void *cc, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a721823fe2126a6bfd7d10a6ec7f74ac3">sph_haval224_4_addbits_and_close</a> (void *cc, unsigned ub, unsigned n, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a9f6a543fc7844d6f2ba35de14c37ac14">sph_haval224_5_init</a> (void *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a5045220877738a223aec74680a1f55b8">sph_haval224_5</a> (void *cc, const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ad1c9618edcf3d2f471443db62c0a2284">sph_haval224_5_close</a> (void *cc, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ae18b7ec999d97d77917de7f031ed0145">sph_haval224_5_addbits_and_close</a> (void *cc, unsigned ub, unsigned n, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ab7d4c3b3d5e984407215ccac7228b3de">sph_haval256_3_init</a> (void *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#aca47290652e0ea0faf9a637093890711">sph_haval256_3</a> (void *cc, const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a5e48594d5f8eeadfe6641b07915fa59b">sph_haval256_3_close</a> (void *cc, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a4899d202efd669d59c2c4ec3515ec168">sph_haval256_3_addbits_and_close</a> (void *cc, unsigned ub, unsigned n, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#ad70d8ed3de4dc22d9c49e62baef4cda1">sph_haval256_4_init</a> (void *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a2eaf99e5bb524ad7d8f5a8a90611d21c">sph_haval256_4</a> (void *cc, const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#acbb67fc27b14789346cb7e0fd82c5862">sph_haval256_4_close</a> (void *cc, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a117bc452f1891077cc6c388279700191">sph_haval256_4_addbits_and_close</a> (void *cc, unsigned ub, unsigned n, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#aafe8ac09e0a7ec4a950cfa4fd9f959e2">sph_haval256_5_init</a> (void *cc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a79980c7ef264dd52d4d39da0f141d81f">sph_haval256_5</a> (void *cc, const void *data, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a5e0ee6fd552a6795ffc4804ece5342e9">sph_haval256_5_close</a> (void *cc, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#af0740ef632b8f99796fb5c6aca84da54">sph_haval256_5_addbits_and_close</a> (void *cc, unsigned ub, unsigned n, void *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a8f7567b2f58a47e6e29059e1da2b3440">sph_haval_3_comp</a> (const <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> msg[32], <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> val[8])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#af2ba3f89acff35dc150d5696f4d853ea">sph_haval_4_comp</a> (const <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> msg[32], <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> val[8])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__haval_8h.html#a1d2858551d51b2ec13c125cd48297a5c">sph_haval_5_comp</a> (const <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> msg[32], <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> val[8])</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>HAVAL interface.</p>
<p>HAVAL is actually a family of 15 hash functions, depending on whether the internal computation uses 3, 4 or 5 passes, and on the output length, which is 128, 160, 192, 224 or 256 bits. This implementation provides interface functions for all 15, which internally map to three cores (depending on the number of passes). Note that output lengths other than 256 bits are not obtained by a simple truncation of a longer result; the requested length is encoded within the padding data.</p>
<p>HAVAL was published in: Yuliang Zheng, Josef Pieprzyk and Jennifer Seberry: "HAVAL -- a one-way hashing algorithm with variable length
 of output", Advances in Cryptology -- AUSCRYPT'92, Lecture Notes in Computer Science, Vol.718, pp.83-104, Springer-Verlag, 1993.</p>
<p>This paper, and a reference implementation, are available on the Calyptix web site: <a href="http://labs.calyptix.com/haval.php">http://labs.calyptix.com/haval.php</a></p>
<p>The HAVAL reference paper is quite unclear on the data encoding details, i.e. endianness (both byte order within a 32-bit word, and word order within a message block). This implementation has been made compatible with the reference implementation referenced above.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A collision for HAVAL-128/3 (HAVAL with three passes and 128-bit output) has been published; this function is thus considered as cryptographically broken. The status for other variants is unclear; use only with care.</dd></dl>
<p>==========================(LICENSE BEGIN)============================</p>
<p>Copyright (c) 2007-2010 Projet RNRT SAPHIR</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<p>===========================(LICENSE END)=============================</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Thomas Pornin &lt;<a href="mailto:thomas.pornin@cryptolog.com">thomas.pornin@cryptolog.com</a>&gt; </dd></dl>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a6566ab1af5e33159dfbddc5bddec87a6"></a><!-- doxytag: member="sph_haval.h::SPH_SIZE_haval128_3" ref="a6566ab1af5e33159dfbddc5bddec87a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_SIZE_haval128_3&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output size (in bits) for HAVAL-128/3. </p>

</div>
</div>
<a class="anchor" id="a87614e72d35880a2e45989f7dc08fdb7"></a><!-- doxytag: member="sph_haval.h::SPH_SIZE_haval128_4" ref="a87614e72d35880a2e45989f7dc08fdb7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_SIZE_haval128_4&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output size (in bits) for HAVAL-128/4. </p>

</div>
</div>
<a class="anchor" id="ab58f3bb53ab00944e47e06d5f5965e74"></a><!-- doxytag: member="sph_haval.h::SPH_SIZE_haval128_5" ref="ab58f3bb53ab00944e47e06d5f5965e74" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_SIZE_haval128_5&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output size (in bits) for HAVAL-128/5. </p>

</div>
</div>
<a class="anchor" id="aaf27d1e974d0054cba6089f69fe04e8e"></a><!-- doxytag: member="sph_haval.h::SPH_SIZE_haval160_3" ref="aaf27d1e974d0054cba6089f69fe04e8e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_SIZE_haval160_3&#160;&#160;&#160;160</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output size (in bits) for HAVAL-160/3. </p>

</div>
</div>
<a class="anchor" id="afdafbffe5efbbb9cb8fee4168e54906c"></a><!-- doxytag: member="sph_haval.h::SPH_SIZE_haval160_4" ref="afdafbffe5efbbb9cb8fee4168e54906c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_SIZE_haval160_4&#160;&#160;&#160;160</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output size (in bits) for HAVAL-160/4. </p>

</div>
</div>
<a class="anchor" id="ae46fa31ac7c2233d259d60aa1bd0a32b"></a><!-- doxytag: member="sph_haval.h::SPH_SIZE_haval160_5" ref="ae46fa31ac7c2233d259d60aa1bd0a32b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_SIZE_haval160_5&#160;&#160;&#160;160</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output size (in bits) for HAVAL-160/5. </p>

</div>
</div>
<a class="anchor" id="a7d38ae85191334b4b823d727b1178310"></a><!-- doxytag: member="sph_haval.h::SPH_SIZE_haval192_3" ref="a7d38ae85191334b4b823d727b1178310" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_SIZE_haval192_3&#160;&#160;&#160;192</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output size (in bits) for HAVAL-192/3. </p>

</div>
</div>
<a class="anchor" id="ab2eb2674346d14adfb68c5298d91e9d0"></a><!-- doxytag: member="sph_haval.h::SPH_SIZE_haval192_4" ref="ab2eb2674346d14adfb68c5298d91e9d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_SIZE_haval192_4&#160;&#160;&#160;192</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output size (in bits) for HAVAL-192/4. </p>

</div>
</div>
<a class="anchor" id="a4cca5a9b360f4260ef519443f4b7e8ed"></a><!-- doxytag: member="sph_haval.h::SPH_SIZE_haval192_5" ref="a4cca5a9b360f4260ef519443f4b7e8ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_SIZE_haval192_5&#160;&#160;&#160;192</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output size (in bits) for HAVAL-192/5. </p>

</div>
</div>
<a class="anchor" id="ac699591e932ae4ce9edc76e4c2a877e6"></a><!-- doxytag: member="sph_haval.h::SPH_SIZE_haval224_3" ref="ac699591e932ae4ce9edc76e4c2a877e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_SIZE_haval224_3&#160;&#160;&#160;224</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output size (in bits) for HAVAL-224/3. </p>

</div>
</div>
<a class="anchor" id="adf84e49d2af75c297895838b0777bc32"></a><!-- doxytag: member="sph_haval.h::SPH_SIZE_haval224_4" ref="adf84e49d2af75c297895838b0777bc32" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_SIZE_haval224_4&#160;&#160;&#160;224</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output size (in bits) for HAVAL-224/4. </p>

</div>
</div>
<a class="anchor" id="a5089a8a5b5268e001fb1bad4ba586581"></a><!-- doxytag: member="sph_haval.h::SPH_SIZE_haval224_5" ref="a5089a8a5b5268e001fb1bad4ba586581" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_SIZE_haval224_5&#160;&#160;&#160;224</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output size (in bits) for HAVAL-224/5. </p>

</div>
</div>
<a class="anchor" id="a92f4819107a3ecd3f2bebc80738da480"></a><!-- doxytag: member="sph_haval.h::SPH_SIZE_haval256_3" ref="a92f4819107a3ecd3f2bebc80738da480" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_SIZE_haval256_3&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output size (in bits) for HAVAL-256/3. </p>

</div>
</div>
<a class="anchor" id="a153340daffab6e964d7564a5f47a020f"></a><!-- doxytag: member="sph_haval.h::SPH_SIZE_haval256_4" ref="a153340daffab6e964d7564a5f47a020f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_SIZE_haval256_4&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output size (in bits) for HAVAL-256/4. </p>

</div>
</div>
<a class="anchor" id="ab378eac8c78a9d217704a8479158c13a"></a><!-- doxytag: member="sph_haval.h::SPH_SIZE_haval256_5" ref="ab378eac8c78a9d217704a8479158c13a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_SIZE_haval256_5&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output size (in bits) for HAVAL-256/5. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="af367124146a73bbb4beaf880c68d6a2d"></a><!-- doxytag: member="sph_haval.h::sph_haval128_3_context" ref="af367124146a73bbb4beaf880c68d6a2d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a> <a class="el" href="structsph__haval__context.html">sph_haval128_3_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a HAVAL-128/3 context (identical to the common context). </p>

</div>
</div>
<a class="anchor" id="aa65646bf0d6291f7549ed49532c0859c"></a><!-- doxytag: member="sph_haval.h::sph_haval128_4_context" ref="aa65646bf0d6291f7549ed49532c0859c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a> <a class="el" href="structsph__haval__context.html">sph_haval128_4_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a HAVAL-128/4 context (identical to the common context). </p>

</div>
</div>
<a class="anchor" id="aef6d1a93f1cae0ef525081b25a841f69"></a><!-- doxytag: member="sph_haval.h::sph_haval128_5_context" ref="aef6d1a93f1cae0ef525081b25a841f69" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a> <a class="el" href="structsph__haval__context.html">sph_haval128_5_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a HAVAL-128/5 context (identical to the common context). </p>

</div>
</div>
<a class="anchor" id="ae3e415cef1b3a3cf6d4a10cdef5fc21b"></a><!-- doxytag: member="sph_haval.h::sph_haval160_3_context" ref="ae3e415cef1b3a3cf6d4a10cdef5fc21b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a> <a class="el" href="structsph__haval__context.html">sph_haval160_3_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a HAVAL-160/3 context (identical to the common context). </p>

</div>
</div>
<a class="anchor" id="ac49122e7de97c791c9e618da4a9b892f"></a><!-- doxytag: member="sph_haval.h::sph_haval160_4_context" ref="ac49122e7de97c791c9e618da4a9b892f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a> <a class="el" href="structsph__haval__context.html">sph_haval160_4_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a HAVAL-160/4 context (identical to the common context). </p>

</div>
</div>
<a class="anchor" id="af7ab4a92a5f616b9d3ddb4f1bb4706fe"></a><!-- doxytag: member="sph_haval.h::sph_haval160_5_context" ref="af7ab4a92a5f616b9d3ddb4f1bb4706fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a> <a class="el" href="structsph__haval__context.html">sph_haval160_5_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a HAVAL-160/5 context (identical to the common context). </p>

</div>
</div>
<a class="anchor" id="ad76e94e6ecea41ca308131287abbd453"></a><!-- doxytag: member="sph_haval.h::sph_haval192_3_context" ref="ad76e94e6ecea41ca308131287abbd453" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a> <a class="el" href="structsph__haval__context.html">sph_haval192_3_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a HAVAL-192/3 context (identical to the common context). </p>

</div>
</div>
<a class="anchor" id="a8d921ce5963297db828c2e2a85160c35"></a><!-- doxytag: member="sph_haval.h::sph_haval192_4_context" ref="a8d921ce5963297db828c2e2a85160c35" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a> <a class="el" href="structsph__haval__context.html">sph_haval192_4_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a HAVAL-192/4 context (identical to the common context). </p>

</div>
</div>
<a class="anchor" id="a4d61ca87df88ffe88c59b86d73f94023"></a><!-- doxytag: member="sph_haval.h::sph_haval192_5_context" ref="a4d61ca87df88ffe88c59b86d73f94023" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a> <a class="el" href="structsph__haval__context.html">sph_haval192_5_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a HAVAL-192/5 context (identical to the common context). </p>

</div>
</div>
<a class="anchor" id="acf1157e57cd3f8bbf25699c93f5053da"></a><!-- doxytag: member="sph_haval.h::sph_haval224_3_context" ref="acf1157e57cd3f8bbf25699c93f5053da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a> <a class="el" href="structsph__haval__context.html">sph_haval224_3_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a HAVAL-224/3 context (identical to the common context). </p>

</div>
</div>
<a class="anchor" id="adb69bded14cbe206a30d08271f9352fa"></a><!-- doxytag: member="sph_haval.h::sph_haval224_4_context" ref="adb69bded14cbe206a30d08271f9352fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a> <a class="el" href="structsph__haval__context.html">sph_haval224_4_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a HAVAL-224/4 context (identical to the common context). </p>

</div>
</div>
<a class="anchor" id="a37ade660f7ea30400190a212ff4e60b1"></a><!-- doxytag: member="sph_haval.h::sph_haval224_5_context" ref="a37ade660f7ea30400190a212ff4e60b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a> <a class="el" href="structsph__haval__context.html">sph_haval224_5_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a HAVAL-224/5 context (identical to the common context). </p>

</div>
</div>
<a class="anchor" id="a8f7de869146cdf91a000551231001617"></a><!-- doxytag: member="sph_haval.h::sph_haval256_3_context" ref="a8f7de869146cdf91a000551231001617" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a> <a class="el" href="structsph__haval__context.html">sph_haval256_3_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a HAVAL-256/3 context (identical to the common context). </p>

</div>
</div>
<a class="anchor" id="a86e47b7bbd76965eacb6a2a30fe8248f"></a><!-- doxytag: member="sph_haval.h::sph_haval256_4_context" ref="a86e47b7bbd76965eacb6a2a30fe8248f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a> <a class="el" href="structsph__haval__context.html">sph_haval256_4_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a HAVAL-256/4 context (identical to the common context). </p>

</div>
</div>
<a class="anchor" id="a0fbdc7e162f9832877ffd7d5810ff21b"></a><!-- doxytag: member="sph_haval.h::sph_haval256_5_context" ref="a0fbdc7e162f9832877ffd7d5810ff21b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsph__haval__context.html">sph_haval_context</a> <a class="el" href="structsph__haval__context.html">sph_haval256_5_context</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a HAVAL-256/5 context (identical to the common context). </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a97bfc1e9d048d1f6e5505527a32f53bc"></a><!-- doxytag: member="sph_haval.h::sph_haval128_3_init" ref="a97bfc1e9d048d1f6e5505527a32f53bc" args="(void *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval128_3_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the context for HAVAL-128/3.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>context to initialize (pointer to a <code>sph_haval128_3_context</code> structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c223fedfa18fe2be493e4f276b5aede"></a><!-- doxytag: member="sph_haval.h::sph_haval128_3" ref="a0c223fedfa18fe2be493e4f276b5aede" args="(void *cc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval128_3 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process some data bytes for HAVAL-128/3. If <code>len</code> is 0, then this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-128/3 context </td></tr>
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">len</td><td>the input data length (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaed1b0fb5f5b2f98c3f5179501de8e7d"></a><!-- doxytag: member="sph_haval.h::sph_haval128_3_close" ref="aaed1b0fb5f5b2f98c3f5179501de8e7d" args="(void *cc, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval128_3_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-128/3 computation. The output buffer must be wide enough to accomodate the result (16 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-128/3 context </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab28b8ad206a96c058d088ecee9355857"></a><!-- doxytag: member="sph_haval.h::sph_haval128_3_addbits_and_close" ref="ab28b8ad206a96c058d088ecee9355857" args="(void *cc, unsigned ub, unsigned n, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval128_3_addbits_and_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-128/3 computation. Up to 7 extra input bits may be added to the input message; these are the <code>n</code> upper bits of the <code>ub</code> byte (i.e. the first extra bit has value 128 in <code>ub</code>, the second extra bit has value 64, and so on). Other bits in <code>ub</code> are ignored.</p>
<p>The output buffer must be wide enough to accomodate the result (16 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-128/3 context </td></tr>
    <tr><td class="paramname">ub</td><td>the extra bits </td></tr>
    <tr><td class="paramname">n</td><td>the number of extra bits (0 to 7) </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0aa4226a1579ac5a2767ccbe59b340fa"></a><!-- doxytag: member="sph_haval.h::sph_haval128_4_init" ref="a0aa4226a1579ac5a2767ccbe59b340fa" args="(void *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval128_4_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the context for HAVAL-128/4.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>context to initialize (pointer to a <code>sph_haval128_4_context</code> structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abee769c1fc556562430acd9e311ad578"></a><!-- doxytag: member="sph_haval.h::sph_haval128_4" ref="abee769c1fc556562430acd9e311ad578" args="(void *cc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval128_4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process some data bytes for HAVAL-128/4. If <code>len</code> is 0, then this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-128/4 context </td></tr>
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">len</td><td>the input data length (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a619d9195ff1f1ebbff30aa6dd325d211"></a><!-- doxytag: member="sph_haval.h::sph_haval128_4_close" ref="a619d9195ff1f1ebbff30aa6dd325d211" args="(void *cc, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval128_4_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-128/4 computation. The output buffer must be wide enough to accomodate the result (16 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-128/4 context </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9080af3e8eb5475ffcacbcaf8053b744"></a><!-- doxytag: member="sph_haval.h::sph_haval128_4_addbits_and_close" ref="a9080af3e8eb5475ffcacbcaf8053b744" args="(void *cc, unsigned ub, unsigned n, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval128_4_addbits_and_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-128/4 computation. Up to 7 extra input bits may be added to the input message; these are the <code>n</code> upper bits of the <code>ub</code> byte (i.e. the first extra bit has value 128 in <code>ub</code>, the second extra bit has value 64, and so on). Other bits in <code>ub</code> are ignored.</p>
<p>The output buffer must be wide enough to accomodate the result (16 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-128/4 context </td></tr>
    <tr><td class="paramname">ub</td><td>the extra bits </td></tr>
    <tr><td class="paramname">n</td><td>the number of extra bits (0 to 7) </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb1c53f44839654b11470c946a1c65a8"></a><!-- doxytag: member="sph_haval.h::sph_haval128_5_init" ref="adb1c53f44839654b11470c946a1c65a8" args="(void *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval128_5_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the context for HAVAL-128/5.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>context to initialize (pointer to a <code>sph_haval128_5_context</code> structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed8b2c71702ce555d6314ef8a4bd275f"></a><!-- doxytag: member="sph_haval.h::sph_haval128_5" ref="aed8b2c71702ce555d6314ef8a4bd275f" args="(void *cc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval128_5 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process some data bytes for HAVAL-128/5. If <code>len</code> is 0, then this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-128/5 context </td></tr>
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">len</td><td>the input data length (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0cb97e02f9b5299c045b8347fdfac97"></a><!-- doxytag: member="sph_haval.h::sph_haval128_5_close" ref="ad0cb97e02f9b5299c045b8347fdfac97" args="(void *cc, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval128_5_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-128/5 computation. The output buffer must be wide enough to accomodate the result (16 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-128/5 context </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a785b6bef2e1554f056eca3b436f89369"></a><!-- doxytag: member="sph_haval.h::sph_haval128_5_addbits_and_close" ref="a785b6bef2e1554f056eca3b436f89369" args="(void *cc, unsigned ub, unsigned n, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval128_5_addbits_and_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-128/5 computation. Up to 7 extra input bits may be added to the input message; these are the <code>n</code> upper bits of the <code>ub</code> byte (i.e. the first extra bit has value 128 in <code>ub</code>, the second extra bit has value 64, and so on). Other bits in <code>ub</code> are ignored.</p>
<p>The output buffer must be wide enough to accomodate the result (16 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-128/5 context </td></tr>
    <tr><td class="paramname">ub</td><td>the extra bits </td></tr>
    <tr><td class="paramname">n</td><td>the number of extra bits (0 to 7) </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fcc401332f79b125c581d3c90bda14d"></a><!-- doxytag: member="sph_haval.h::sph_haval160_3_init" ref="a2fcc401332f79b125c581d3c90bda14d" args="(void *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval160_3_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the context for HAVAL-160/3.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>context to initialize (pointer to a <code>sph_haval160_3_context</code> structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f4624148dcb39a5525d0567ceb97e02"></a><!-- doxytag: member="sph_haval.h::sph_haval160_3" ref="a7f4624148dcb39a5525d0567ceb97e02" args="(void *cc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval160_3 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process some data bytes for HAVAL-160/3. If <code>len</code> is 0, then this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-160/3 context </td></tr>
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">len</td><td>the input data length (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6600bef16e1c9b36cc7791c80b595a6b"></a><!-- doxytag: member="sph_haval.h::sph_haval160_3_close" ref="a6600bef16e1c9b36cc7791c80b595a6b" args="(void *cc, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval160_3_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-160/3 computation. The output buffer must be wide enough to accomodate the result (20 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-160/3 context </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fd12367e784029b77198cf4525334dc"></a><!-- doxytag: member="sph_haval.h::sph_haval160_3_addbits_and_close" ref="a2fd12367e784029b77198cf4525334dc" args="(void *cc, unsigned ub, unsigned n, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval160_3_addbits_and_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-160/3 computation. Up to 7 extra input bits may be added to the input message; these are the <code>n</code> upper bits of the <code>ub</code> byte (i.e. the first extra bit has value 128 in <code>ub</code>, the second extra bit has value 64, and so on). Other bits in <code>ub</code> are ignored.</p>
<p>The output buffer must be wide enough to accomodate the result (20 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-160/3 context </td></tr>
    <tr><td class="paramname">ub</td><td>the extra bits </td></tr>
    <tr><td class="paramname">n</td><td>the number of extra bits (0 to 7) </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer</td></tr>
  </table>
  </dd>
</dl>
<p>Close a HAVAL-160/4 computation. Up to 7 extra input bits may be added to the input message; these are the <code>n</code> upper bits of the <code>ub</code> byte (i.e. the first extra bit has value 128 in <code>ub</code>, the second extra bit has value 64, and so on). Other bits in <code>ub</code> are ignored.</p>
<p>The output buffer must be wide enough to accomodate the result (20 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-160/4 context </td></tr>
    <tr><td class="paramname">ub</td><td>the extra bits </td></tr>
    <tr><td class="paramname">n</td><td>the number of extra bits (0 to 7) </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a817499926eb781d2a576c2a883a1aa"></a><!-- doxytag: member="sph_haval.h::sph_haval160_4_init" ref="a2a817499926eb781d2a576c2a883a1aa" args="(void *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval160_4_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the context for HAVAL-160/4.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>context to initialize (pointer to a <code>sph_haval160_4_context</code> structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5875ec97daa77c5f3c8c4781abccf086"></a><!-- doxytag: member="sph_haval.h::sph_haval160_4" ref="a5875ec97daa77c5f3c8c4781abccf086" args="(void *cc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval160_4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process some data bytes for HAVAL-160/4. If <code>len</code> is 0, then this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-160/4 context </td></tr>
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">len</td><td>the input data length (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36b5108446181627136e96d5d6753e61"></a><!-- doxytag: member="sph_haval.h::sph_haval160_4_close" ref="a36b5108446181627136e96d5d6753e61" args="(void *cc, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval160_4_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-160/4 computation. The output buffer must be wide enough to accomodate the result (20 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-160/4 context </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5aa0b40d3f6c5445348796aa26b06111"></a><!-- doxytag: member="sph_haval.h::sph_haval160_5_init" ref="a5aa0b40d3f6c5445348796aa26b06111" args="(void *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval160_5_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the context for HAVAL-160/5.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>context to initialize (pointer to a <code>sph_haval160_5_context</code> structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75c1ea042c2aaa29396292870723274d"></a><!-- doxytag: member="sph_haval.h::sph_haval160_5" ref="a75c1ea042c2aaa29396292870723274d" args="(void *cc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval160_5 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process some data bytes for HAVAL-160/5. If <code>len</code> is 0, then this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-160/5 context </td></tr>
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">len</td><td>the input data length (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a44c89f408a258d46fbb5c4a8183e0c78"></a><!-- doxytag: member="sph_haval.h::sph_haval160_5_close" ref="a44c89f408a258d46fbb5c4a8183e0c78" args="(void *cc, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval160_5_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-160/5 computation. The output buffer must be wide enough to accomodate the result (20 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-160/5 context </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acac70255293c678ab1105b563c1cb8d9"></a><!-- doxytag: member="sph_haval.h::sph_haval160_5_addbits_and_close" ref="acac70255293c678ab1105b563c1cb8d9" args="(void *cc, unsigned ub, unsigned n, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval160_5_addbits_and_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-160/5 computation. Up to 7 extra input bits may be added to the input message; these are the <code>n</code> upper bits of the <code>ub</code> byte (i.e. the first extra bit has value 128 in <code>ub</code>, the second extra bit has value 64, and so on). Other bits in <code>ub</code> are ignored.</p>
<p>The output buffer must be wide enough to accomodate the result (20 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-160/5 context </td></tr>
    <tr><td class="paramname">ub</td><td>the extra bits </td></tr>
    <tr><td class="paramname">n</td><td>the number of extra bits (0 to 7) </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4bb8e4b4a023767c3b94acec84007d73"></a><!-- doxytag: member="sph_haval.h::sph_haval192_3_init" ref="a4bb8e4b4a023767c3b94acec84007d73" args="(void *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval192_3_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the context for HAVAL-192/3.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>context to initialize (pointer to a <code>sph_haval192_3_context</code> structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a596fe2cec90956f667679079fc04b9c3"></a><!-- doxytag: member="sph_haval.h::sph_haval192_3" ref="a596fe2cec90956f667679079fc04b9c3" args="(void *cc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval192_3 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process some data bytes for HAVAL-192/3. If <code>len</code> is 0, then this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-192/3 context </td></tr>
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">len</td><td>the input data length (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a238cc6ff3ce791456fbe0b5557cc383f"></a><!-- doxytag: member="sph_haval.h::sph_haval192_3_close" ref="a238cc6ff3ce791456fbe0b5557cc383f" args="(void *cc, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval192_3_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-192/3 computation. The output buffer must be wide enough to accomodate the result (24 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-192/3 context </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c556aef11bb380ec28656a94b5f4605"></a><!-- doxytag: member="sph_haval.h::sph_haval192_3_addbits_and_close" ref="a0c556aef11bb380ec28656a94b5f4605" args="(void *cc, unsigned ub, unsigned n, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval192_3_addbits_and_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-192/3 computation. Up to 7 extra input bits may be added to the input message; these are the <code>n</code> upper bits of the <code>ub</code> byte (i.e. the first extra bit has value 128 in <code>ub</code>, the second extra bit has value 64, and so on). Other bits in <code>ub</code> are ignored.</p>
<p>The output buffer must be wide enough to accomodate the result (24 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-192/3 context </td></tr>
    <tr><td class="paramname">ub</td><td>the extra bits </td></tr>
    <tr><td class="paramname">n</td><td>the number of extra bits (0 to 7) </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b36e600635b9cd4c1e04d7fa7d9605d"></a><!-- doxytag: member="sph_haval.h::sph_haval192_4_init" ref="a5b36e600635b9cd4c1e04d7fa7d9605d" args="(void *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval192_4_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the context for HAVAL-192/4.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>context to initialize (pointer to a <code>sph_haval192_4_context</code> structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f40969f0baaec457a9a01c1cb11af8c"></a><!-- doxytag: member="sph_haval.h::sph_haval192_4" ref="a4f40969f0baaec457a9a01c1cb11af8c" args="(void *cc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval192_4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process some data bytes for HAVAL-192/4. If <code>len</code> is 0, then this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-192/4 context </td></tr>
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">len</td><td>the input data length (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad68d957b663970e4b3897aa05eac28c"></a><!-- doxytag: member="sph_haval.h::sph_haval192_4_close" ref="aad68d957b663970e4b3897aa05eac28c" args="(void *cc, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval192_4_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-192/4 computation. The output buffer must be wide enough to accomodate the result (24 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-192/4 context </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b2b42f14cb67f29c77ee29794fe02a6"></a><!-- doxytag: member="sph_haval.h::sph_haval192_4_addbits_and_close" ref="a5b2b42f14cb67f29c77ee29794fe02a6" args="(void *cc, unsigned ub, unsigned n, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval192_4_addbits_and_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-192/4 computation. Up to 7 extra input bits may be added to the input message; these are the <code>n</code> upper bits of the <code>ub</code> byte (i.e. the first extra bit has value 128 in <code>ub</code>, the second extra bit has value 64, and so on). Other bits in <code>ub</code> are ignored.</p>
<p>The output buffer must be wide enough to accomodate the result (24 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-192/4 context </td></tr>
    <tr><td class="paramname">ub</td><td>the extra bits </td></tr>
    <tr><td class="paramname">n</td><td>the number of extra bits (0 to 7) </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a76545063eca775308ff9b57b59ed24"></a><!-- doxytag: member="sph_haval.h::sph_haval192_5_init" ref="a6a76545063eca775308ff9b57b59ed24" args="(void *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval192_5_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the context for HAVAL-192/5.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>context to initialize (pointer to a <code>sph_haval192_5_context</code> structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa01935e7084dbb281ac6ee30f1321ca4"></a><!-- doxytag: member="sph_haval.h::sph_haval192_5" ref="aa01935e7084dbb281ac6ee30f1321ca4" args="(void *cc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval192_5 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process some data bytes for HAVAL-192/5. If <code>len</code> is 0, then this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-192/5 context </td></tr>
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">len</td><td>the input data length (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4a98c330ac620702ff0862e2381a6ff"></a><!-- doxytag: member="sph_haval.h::sph_haval192_5_close" ref="ad4a98c330ac620702ff0862e2381a6ff" args="(void *cc, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval192_5_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-192/5 computation. The output buffer must be wide enough to accomodate the result (24 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-192/5 context </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa004124bd3188f03633b8b701b08a3b"></a><!-- doxytag: member="sph_haval.h::sph_haval192_5_addbits_and_close" ref="aaa004124bd3188f03633b8b701b08a3b" args="(void *cc, unsigned ub, unsigned n, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval192_5_addbits_and_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-192/5 computation. Up to 7 extra input bits may be added to the input message; these are the <code>n</code> upper bits of the <code>ub</code> byte (i.e. the first extra bit has value 128 in <code>ub</code>, the second extra bit has value 64, and so on). Other bits in <code>ub</code> are ignored.</p>
<p>The output buffer must be wide enough to accomodate the result (24 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-192/5 context </td></tr>
    <tr><td class="paramname">ub</td><td>the extra bits </td></tr>
    <tr><td class="paramname">n</td><td>the number of extra bits (0 to 7) </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7538ce2f51535aaa724f6c365f328c8"></a><!-- doxytag: member="sph_haval.h::sph_haval224_3_init" ref="ae7538ce2f51535aaa724f6c365f328c8" args="(void *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval224_3_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the context for HAVAL-224/3.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>context to initialize (pointer to a <code>sph_haval224_3_context</code> structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51e48bd1d3ecbf79248712e3dd959494"></a><!-- doxytag: member="sph_haval.h::sph_haval224_3" ref="a51e48bd1d3ecbf79248712e3dd959494" args="(void *cc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval224_3 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process some data bytes for HAVAL-224/3. If <code>len</code> is 0, then this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-224/3 context </td></tr>
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">len</td><td>the input data length (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab86f7b2e9b8b0443b4997015ce600af3"></a><!-- doxytag: member="sph_haval.h::sph_haval224_3_close" ref="ab86f7b2e9b8b0443b4997015ce600af3" args="(void *cc, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval224_3_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-224/3 computation. The output buffer must be wide enough to accomodate the result (28 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-224/3 context </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab0baf31e736678bb3482ea927ab654e"></a><!-- doxytag: member="sph_haval.h::sph_haval224_3_addbits_and_close" ref="aab0baf31e736678bb3482ea927ab654e" args="(void *cc, unsigned ub, unsigned n, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval224_3_addbits_and_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-224/3 computation. Up to 7 extra input bits may be added to the input message; these are the <code>n</code> upper bits of the <code>ub</code> byte (i.e. the first extra bit has value 128 in <code>ub</code>, the second extra bit has value 64, and so on). Other bits in <code>ub</code> are ignored.</p>
<p>The output buffer must be wide enough to accomodate the result (28 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-224/3 context </td></tr>
    <tr><td class="paramname">ub</td><td>the extra bits </td></tr>
    <tr><td class="paramname">n</td><td>the number of extra bits (0 to 7) </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67edea48177c1abf83f14a1fae0b202d"></a><!-- doxytag: member="sph_haval.h::sph_haval224_4_init" ref="a67edea48177c1abf83f14a1fae0b202d" args="(void *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval224_4_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the context for HAVAL-224/4.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>context to initialize (pointer to a <code>sph_haval224_4_context</code> structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b1250c04a76ab0909c87f1addcf6bcb"></a><!-- doxytag: member="sph_haval.h::sph_haval224_4" ref="a9b1250c04a76ab0909c87f1addcf6bcb" args="(void *cc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval224_4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process some data bytes for HAVAL-224/4. If <code>len</code> is 0, then this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-224/4 context </td></tr>
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">len</td><td>the input data length (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1300486b4bbbdea2f5689d3ce93ef6ef"></a><!-- doxytag: member="sph_haval.h::sph_haval224_4_close" ref="a1300486b4bbbdea2f5689d3ce93ef6ef" args="(void *cc, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval224_4_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-224/4 computation. The output buffer must be wide enough to accomodate the result (28 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-224/4 context </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a721823fe2126a6bfd7d10a6ec7f74ac3"></a><!-- doxytag: member="sph_haval.h::sph_haval224_4_addbits_and_close" ref="a721823fe2126a6bfd7d10a6ec7f74ac3" args="(void *cc, unsigned ub, unsigned n, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval224_4_addbits_and_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-224/4 computation. Up to 7 extra input bits may be added to the input message; these are the <code>n</code> upper bits of the <code>ub</code> byte (i.e. the first extra bit has value 128 in <code>ub</code>, the second extra bit has value 64, and so on). Other bits in <code>ub</code> are ignored.</p>
<p>The output buffer must be wide enough to accomodate the result (28 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-224/4 context </td></tr>
    <tr><td class="paramname">ub</td><td>the extra bits </td></tr>
    <tr><td class="paramname">n</td><td>the number of extra bits (0 to 7) </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f6a543fc7844d6f2ba35de14c37ac14"></a><!-- doxytag: member="sph_haval.h::sph_haval224_5_init" ref="a9f6a543fc7844d6f2ba35de14c37ac14" args="(void *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval224_5_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the context for HAVAL-224/5.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>context to initialize (pointer to a <code>sph_haval224_5_context</code> structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5045220877738a223aec74680a1f55b8"></a><!-- doxytag: member="sph_haval.h::sph_haval224_5" ref="a5045220877738a223aec74680a1f55b8" args="(void *cc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval224_5 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process some data bytes for HAVAL-224/5. If <code>len</code> is 0, then this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-224/5 context </td></tr>
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">len</td><td>the input data length (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1c9618edcf3d2f471443db62c0a2284"></a><!-- doxytag: member="sph_haval.h::sph_haval224_5_close" ref="ad1c9618edcf3d2f471443db62c0a2284" args="(void *cc, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval224_5_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-224/5 computation. The output buffer must be wide enough to accomodate the result (28 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-224/5 context </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae18b7ec999d97d77917de7f031ed0145"></a><!-- doxytag: member="sph_haval.h::sph_haval224_5_addbits_and_close" ref="ae18b7ec999d97d77917de7f031ed0145" args="(void *cc, unsigned ub, unsigned n, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval224_5_addbits_and_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-224/5 computation. Up to 7 extra input bits may be added to the input message; these are the <code>n</code> upper bits of the <code>ub</code> byte (i.e. the first extra bit has value 128 in <code>ub</code>, the second extra bit has value 64, and so on). Other bits in <code>ub</code> are ignored.</p>
<p>The output buffer must be wide enough to accomodate the result (28 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-224/5 context </td></tr>
    <tr><td class="paramname">ub</td><td>the extra bits </td></tr>
    <tr><td class="paramname">n</td><td>the number of extra bits (0 to 7) </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7d4c3b3d5e984407215ccac7228b3de"></a><!-- doxytag: member="sph_haval.h::sph_haval256_3_init" ref="ab7d4c3b3d5e984407215ccac7228b3de" args="(void *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval256_3_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the context for HAVAL-256/3.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>context to initialize (pointer to a <code>sph_haval256_3_context</code> structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aca47290652e0ea0faf9a637093890711"></a><!-- doxytag: member="sph_haval.h::sph_haval256_3" ref="aca47290652e0ea0faf9a637093890711" args="(void *cc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval256_3 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process some data bytes for HAVAL-256/3. If <code>len</code> is 0, then this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-256/3 context </td></tr>
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">len</td><td>the input data length (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e48594d5f8eeadfe6641b07915fa59b"></a><!-- doxytag: member="sph_haval.h::sph_haval256_3_close" ref="a5e48594d5f8eeadfe6641b07915fa59b" args="(void *cc, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval256_3_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-256/3 computation. The output buffer must be wide enough to accomodate the result (32 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-256/3 context </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4899d202efd669d59c2c4ec3515ec168"></a><!-- doxytag: member="sph_haval.h::sph_haval256_3_addbits_and_close" ref="a4899d202efd669d59c2c4ec3515ec168" args="(void *cc, unsigned ub, unsigned n, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval256_3_addbits_and_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-256/3 computation. Up to 7 extra input bits may be added to the input message; these are the <code>n</code> upper bits of the <code>ub</code> byte (i.e. the first extra bit has value 128 in <code>ub</code>, the second extra bit has value 64, and so on). Other bits in <code>ub</code> are ignored.</p>
<p>The output buffer must be wide enough to accomodate the result (32 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-256/3 context </td></tr>
    <tr><td class="paramname">ub</td><td>the extra bits </td></tr>
    <tr><td class="paramname">n</td><td>the number of extra bits (0 to 7) </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad70d8ed3de4dc22d9c49e62baef4cda1"></a><!-- doxytag: member="sph_haval.h::sph_haval256_4_init" ref="ad70d8ed3de4dc22d9c49e62baef4cda1" args="(void *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval256_4_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the context for HAVAL-256/4.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>context to initialize (pointer to a <code>sph_haval256_4_context</code> structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2eaf99e5bb524ad7d8f5a8a90611d21c"></a><!-- doxytag: member="sph_haval.h::sph_haval256_4" ref="a2eaf99e5bb524ad7d8f5a8a90611d21c" args="(void *cc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval256_4 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process some data bytes for HAVAL-256/4. If <code>len</code> is 0, then this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-256/4 context </td></tr>
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">len</td><td>the input data length (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbb67fc27b14789346cb7e0fd82c5862"></a><!-- doxytag: member="sph_haval.h::sph_haval256_4_close" ref="acbb67fc27b14789346cb7e0fd82c5862" args="(void *cc, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval256_4_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-256/4 computation. The output buffer must be wide enough to accomodate the result (32 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-256/4 context </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a117bc452f1891077cc6c388279700191"></a><!-- doxytag: member="sph_haval.h::sph_haval256_4_addbits_and_close" ref="a117bc452f1891077cc6c388279700191" args="(void *cc, unsigned ub, unsigned n, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval256_4_addbits_and_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-256/4 computation. Up to 7 extra input bits may be added to the input message; these are the <code>n</code> upper bits of the <code>ub</code> byte (i.e. the first extra bit has value 128 in <code>ub</code>, the second extra bit has value 64, and so on). Other bits in <code>ub</code> are ignored.</p>
<p>The output buffer must be wide enough to accomodate the result (32 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-256/4 context </td></tr>
    <tr><td class="paramname">ub</td><td>the extra bits </td></tr>
    <tr><td class="paramname">n</td><td>the number of extra bits (0 to 7) </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafe8ac09e0a7ec4a950cfa4fd9f959e2"></a><!-- doxytag: member="sph_haval.h::sph_haval256_5_init" ref="aafe8ac09e0a7ec4a950cfa4fd9f959e2" args="(void *cc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval256_5_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the context for HAVAL-256/5.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>context to initialize (pointer to a <code>sph_haval256_5_context</code> structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79980c7ef264dd52d4d39da0f141d81f"></a><!-- doxytag: member="sph_haval.h::sph_haval256_5" ref="a79980c7ef264dd52d4d39da0f141d81f" args="(void *cc, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval256_5 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Process some data bytes for HAVAL-256/5. If <code>len</code> is 0, then this function does nothing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-256/5 context </td></tr>
    <tr><td class="paramname">data</td><td>the input data </td></tr>
    <tr><td class="paramname">len</td><td>the input data length (in bytes) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e0ee6fd552a6795ffc4804ece5342e9"></a><!-- doxytag: member="sph_haval.h::sph_haval256_5_close" ref="a5e0ee6fd552a6795ffc4804ece5342e9" args="(void *cc, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval256_5_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-256/5 computation. The output buffer must be wide enough to accomodate the result (32 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-256/5 context </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0740ef632b8f99796fb5c6aca84da54"></a><!-- doxytag: member="sph_haval.h::sph_haval256_5_addbits_and_close" ref="af0740ef632b8f99796fb5c6aca84da54" args="(void *cc, unsigned ub, unsigned n, void *dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval256_5_addbits_and_close </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a HAVAL-256/5 computation. Up to 7 extra input bits may be added to the input message; these are the <code>n</code> upper bits of the <code>ub</code> byte (i.e. the first extra bit has value 128 in <code>ub</code>, the second extra bit has value 64, and so on). Other bits in <code>ub</code> are ignored.</p>
<p>The output buffer must be wide enough to accomodate the result (32 bytes). The context is automatically reinitialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>the HAVAL-256/5 context </td></tr>
    <tr><td class="paramname">ub</td><td>the extra bits </td></tr>
    <tr><td class="paramname">n</td><td>the number of extra bits (0 to 7) </td></tr>
    <tr><td class="paramname">dst</td><td>the output buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f7567b2f58a47e6e29059e1da2b3440"></a><!-- doxytag: member="sph_haval.h::sph_haval_3_comp" ref="a8f7567b2f58a47e6e29059e1da2b3440" args="(const sph_u32 msg[32], sph_u32 val[8])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval_3_comp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td>
          <td class="paramname"><em>msg</em>[32], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td>
          <td class="paramname"><em>val</em>[8]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the HAVAL compression function on the provided data. The <code>msg</code> parameter contains the 32 32-bit input blocks, as numerical values (hence after the little-endian decoding). The <code>val</code> parameter contains the 8 32-bit input blocks for the compression function; the output is written in place in this array. This function uses three internal passes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the message block (32 values) </td></tr>
    <tr><td class="paramname">val</td><td>the function 256-bit input and output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2ba3f89acff35dc150d5696f4d853ea"></a><!-- doxytag: member="sph_haval.h::sph_haval_4_comp" ref="af2ba3f89acff35dc150d5696f4d853ea" args="(const sph_u32 msg[32], sph_u32 val[8])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval_4_comp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td>
          <td class="paramname"><em>msg</em>[32], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td>
          <td class="paramname"><em>val</em>[8]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the HAVAL compression function on the provided data. The <code>msg</code> parameter contains the 32 32-bit input blocks, as numerical values (hence after the little-endian decoding). The <code>val</code> parameter contains the 8 32-bit input blocks for the compression function; the output is written in place in this array. This function uses four internal passes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the message block (32 values) </td></tr>
    <tr><td class="paramname">val</td><td>the function 256-bit input and output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d2858551d51b2ec13c125cd48297a5c"></a><!-- doxytag: member="sph_haval.h::sph_haval_5_comp" ref="a1d2858551d51b2ec13c125cd48297a5c" args="(const sph_u32 msg[32], sph_u32 val[8])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sph_haval_5_comp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td>
          <td class="paramname"><em>msg</em>[32], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td>
          <td class="paramname"><em>val</em>[8]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the HAVAL compression function on the provided data. The <code>msg</code> parameter contains the 32 32-bit input blocks, as numerical values (hence after the little-endian decoding). The <code>val</code> parameter contains the 8 32-bit input blocks for the compression function; the output is written in place in this array. This function uses five internal passes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the message block (32 values) </td></tr>
    <tr><td class="paramname">val</td><td>the function 256-bit input and output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Jul 20 2011 21:15:30 for sphlib by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
