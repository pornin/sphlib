<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>sphlib: sph_types.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">sphlib</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>sph_types.h File Reference</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;limits.h&gt;</code><br/>
</div>
<p><a href="sph__types_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a9aa5041e567e11581beb3237623b7af0">SPH_C32</a>(x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a6b2da7fb1eca675723880c22fa7918ca">SPH_T32</a>(x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a2f0780c6a4e1d5f1b3845d48fe8b1f9f">SPH_ROTL32</a>(x, n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a8bc9d8182b074b7bd4752658034df72d">SPH_ROTR32</a>(x, n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a383758264298b1cb816e1aa5b8143e74">SPH_64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#aa0762a5223a026586eecaeb11932071d">SPH_64_TRUE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#ae0984a800c78947d723a27a4bbf61a62">SPH_C64</a>(x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a862296a164555017b55e37bb09e20162">SPH_T64</a>(x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a0cd067baca3c2ed4b2f3e048dd503393">SPH_ROTL64</a>(x, n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a2f3d33872596a0f5f3cf36b9eecdca5b">SPH_ROTR64</a>(x, n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#af65f6f033a520b641563a2574c5d1df8">SPH_INLINE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#ae933da6e8036611f455b220e5fd54518">SPH_LITTLE_ENDIAN</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a89fe884c64ec670a09eb9792b6614dd7">SPH_BIG_ENDIAN</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a446ac387eeb89e845682be803b40c308">SPH_LITTLE_FAST</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a566b63ce77b2a83dff599f829819d80d">SPH_BIG_FAST</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#add0ead78918ca1b3c98eefd65854b8fa">SPH_UPTR</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#aea5170f5e2463294bb3c5858742c416b">SPH_UNALIGNED</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef __arch_dependant__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef __arch_dependant__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a9096255be60de8b630c6d268461a0972">sph_s32</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef __arch_dependant__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef __arch_dependant__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#ae48722d443535f1e82905e742f2b3d11">sph_s64</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#aa21c79a8abd42546ea5862eca100acce">sph_bswap32</a> (<a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a9fe9a72d55ebe6b5f47925a631eb5030">sph_bswap64</a> (<a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a> x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a7f729a6c8b9ead5cb2b0835aeae3217d">sph_dec16le</a> (const void *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a6107a9b15c1ba89e5b37e1bb728ad654">sph_enc16le</a> (void *dst, unsigned val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a19d8b62deef02aac1b42b6606e5eabd4">sph_dec16be</a> (const void *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#ae84619401c2338dd568d7466e2000279">sph_enc16be</a> (void *dst, unsigned val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#ad3eeb6346fffa1029a239fe94bfdc4e6">sph_dec32le</a> (const void *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#ac808629acbf32dba42e5259b40983528">sph_dec32le_aligned</a> (const void *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#ac1eaa2034411e7619613a70a3813d074">sph_enc32le</a> (void *dst, <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a77c96bbda2549c001f7807a035cf4d42">sph_enc32le_aligned</a> (void *dst, <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a0334b8b7e706679f1e6588305eb194df">sph_dec32be</a> (const void *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a1dbf6ceed8e6a9bf198ad5e759b62d54">sph_dec32be_aligned</a> (const void *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a15f055c4bbfa9f4c296c2b41fd163ba1">sph_enc32be</a> (void *dst, <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a8e05e0b98da9cc62523d171bbbffd04e">sph_enc32be_aligned</a> (void *dst, <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#aacbb6c4e2857cbe072efc28668e4235b">sph_dec64le</a> (const void *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#ab622d8132749d2030f11d805a381cf24">sph_dec64le_aligned</a> (const void *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#ad941f3fa0312fe430d675595c9f56444">sph_enc64le</a> (void *dst, <a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a> val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a18be3c60bf0074d44a241a4671af81fc">sph_enc64le_aligned</a> (void *dst, <a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a> val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a26b1954cb1e2377c8aee81cb03446f8b">sph_dec64be</a> (const void *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a46484fd5d8c4780edca4b4e4df05f95b">sph_dec64be_aligned</a> (const void *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#a690d29ac8e29c8d0c09d72914bf120d2">sph_enc64be</a> (void *dst, <a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a> val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph__types_8h.html#ac6ea69fade68ec76765ac37f379787d2">sph_enc64be_aligned</a> (void *dst, <a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a> val)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Basic type definitions.</p>
<p>This header file defines the generic integer types that will be used for the implementation of hash functions; it also contains helper functions which encode and decode multi-byte integer values, using either little-endian or big-endian conventions.</p>
<p>This file contains a compile-time test on the size of a byte (the <code>unsigned char</code> C type). If bytes are not octets, i.e. if they do not have a size of exactly 8 bits, then compilation is aborted. Architectures where bytes are not octets are relatively rare, even in the embedded devices market. We forbid non-octet bytes because there is no clear convention on how octet streams are encoded on such systems.</p>
<p>==========================(LICENSE BEGIN)============================</p>
<p>Copyright (c) 2007-2010 Projet RNRT SAPHIR</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<p>===========================(LICENSE END)=============================</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Thomas Pornin &lt;<a href="mailto:thomas.pornin@cryptolog.com">thomas.pornin@cryptolog.com</a>&gt; </dd></dl>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a9aa5041e567e11581beb3237623b7af0"></a><!-- doxytag: member="sph_types.h::SPH_C32" ref="a9aa5041e567e11581beb3237623b7af0" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_C32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro expands the token <code>x</code> into a suitable constant expression of type <code>sph_u32</code>. Depending on how this type is defined, a suffix such as <code>UL</code> may be appended to the argument.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the token to expand into a suitable constant expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b2da7fb1eca675723880c22fa7918ca"></a><!-- doxytag: member="sph_types.h::SPH_T32" ref="a6b2da7fb1eca675723880c22fa7918ca" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_T32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Truncate a 32-bit value to exactly 32 bits. On most systems, this is a no-op, recognized as such by the compiler.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to truncate (of type <code>sph_u32</code>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f0780c6a4e1d5f1b3845d48fe8b1f9f"></a><!-- doxytag: member="sph_types.h::SPH_ROTL32" ref="a2f0780c6a4e1d5f1b3845d48fe8b1f9f" args="(x, n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_ROTL32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rotate a 32-bit value by a number of bits to the left. The rotate count must reside between 1 and 31. This macro assumes that its first argument fits in 32 bits (no extra bit allowed on machines where <code>sph_u32</code> is wider); both arguments may be evaluated several times.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate (of type <code>sph_u32</code>) </td></tr>
    <tr><td class="paramname">n</td><td>the rotation count (between 1 and 31, inclusive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bc9d8182b074b7bd4752658034df72d"></a><!-- doxytag: member="sph_types.h::SPH_ROTR32" ref="a8bc9d8182b074b7bd4752658034df72d" args="(x, n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_ROTR32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rotate a 32-bit value by a number of bits to the left. The rotate count must reside between 1 and 31. This macro assumes that its first argument fits in 32 bits (no extra bit allowed on machines where <code>sph_u32</code> is wider); both arguments may be evaluated several times.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate (of type <code>sph_u32</code>) </td></tr>
    <tr><td class="paramname">n</td><td>the rotation count (between 1 and 31, inclusive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a383758264298b1cb816e1aa5b8143e74"></a><!-- doxytag: member="sph_types.h::SPH_64" ref="a383758264298b1cb816e1aa5b8143e74" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_64</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro is defined on systems for which a 64-bit type has been detected, and is used for <code>sph_u64</code>. </p>

</div>
</div>
<a class="anchor" id="aa0762a5223a026586eecaeb11932071d"></a><!-- doxytag: member="sph_types.h::SPH_64_TRUE" ref="aa0762a5223a026586eecaeb11932071d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_64_TRUE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro is defined on systems for the "native" integer size is 64 bits (64-bit values fit in one register). </p>

</div>
</div>
<a class="anchor" id="ae0984a800c78947d723a27a4bbf61a62"></a><!-- doxytag: member="sph_types.h::SPH_C64" ref="ae0984a800c78947d723a27a4bbf61a62" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_C64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro expands the token <code>x</code> into a suitable constant expression of type <code>sph_u64</code>. Depending on how this type is defined, a suffix such as <code>ULL</code> may be appended to the argument. This macro is defined only if a 64-bit type was detected and used for <code>sph_u64</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the token to expand into a suitable constant expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a862296a164555017b55e37bb09e20162"></a><!-- doxytag: member="sph_types.h::SPH_T64" ref="a862296a164555017b55e37bb09e20162" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_T64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Truncate a 64-bit value to exactly 64 bits. On most systems, this is a no-op, recognized as such by the compiler. This macro is defined only if a 64-bit type was detected and used for <code>sph_u64</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to truncate (of type <code>sph_u64</code>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0cd067baca3c2ed4b2f3e048dd503393"></a><!-- doxytag: member="sph_types.h::SPH_ROTL64" ref="a0cd067baca3c2ed4b2f3e048dd503393" args="(x, n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_ROTL64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rotate a 64-bit value by a number of bits to the left. The rotate count must reside between 1 and 63. This macro assumes that its first argument fits in 64 bits (no extra bit allowed on machines where <code>sph_u64</code> is wider); both arguments may be evaluated several times. This macro is defined only if a 64-bit type was detected and used for <code>sph_u64</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate (of type <code>sph_u64</code>) </td></tr>
    <tr><td class="paramname">n</td><td>the rotation count (between 1 and 63, inclusive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f3d33872596a0f5f3cf36b9eecdca5b"></a><!-- doxytag: member="sph_types.h::SPH_ROTR64" ref="a2f3d33872596a0f5f3cf36b9eecdca5b" args="(x, n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_ROTR64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rotate a 64-bit value by a number of bits to the left. The rotate count must reside between 1 and 63. This macro assumes that its first argument fits in 64 bits (no extra bit allowed on machines where <code>sph_u64</code> is wider); both arguments may be evaluated several times. This macro is defined only if a 64-bit type was detected and used for <code>sph_u64</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to rotate (of type <code>sph_u64</code>) </td></tr>
    <tr><td class="paramname">n</td><td>the rotation count (between 1 and 63, inclusive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af65f6f033a520b641563a2574c5d1df8"></a><!-- doxytag: member="sph_types.h::SPH_INLINE" ref="af65f6f033a520b641563a2574c5d1df8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_INLINE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro evaluates to <code>inline</code> or an equivalent construction, if available on the compilation platform, or to nothing otherwise. This is used to declare inline functions, for which the compiler should endeavour to include the code directly in the caller. Inline functions are typically defined in header files as replacement for macros. </p>

</div>
</div>
<a class="anchor" id="ae933da6e8036611f455b220e5fd54518"></a><!-- doxytag: member="sph_types.h::SPH_LITTLE_ENDIAN" ref="ae933da6e8036611f455b220e5fd54518" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_LITTLE_ENDIAN</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro is defined if the platform has been detected as using little-endian convention. This implies that the <code>sph_u32</code> type (and the <code>sph_u64</code> type also, if it is defined) has an exact width (i.e. exactly 32-bit, respectively 64-bit). </p>

</div>
</div>
<a class="anchor" id="a89fe884c64ec670a09eb9792b6614dd7"></a><!-- doxytag: member="sph_types.h::SPH_BIG_ENDIAN" ref="a89fe884c64ec670a09eb9792b6614dd7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_BIG_ENDIAN</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro is defined if the platform has been detected as using big-endian convention. This implies that the <code>sph_u32</code> type (and the <code>sph_u64</code> type also, if it is defined) has an exact width (i.e. exactly 32-bit, respectively 64-bit). </p>

</div>
</div>
<a class="anchor" id="a446ac387eeb89e845682be803b40c308"></a><!-- doxytag: member="sph_types.h::SPH_LITTLE_FAST" ref="a446ac387eeb89e845682be803b40c308" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_LITTLE_FAST</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro is defined if 32-bit words (and 64-bit words, if defined) can be read from and written to memory efficiently in little-endian convention. This is the case for little-endian platforms, and also for the big-endian platforms which have special little-endian access opcodes (e.g. Ultrasparc). </p>

</div>
</div>
<a class="anchor" id="a566b63ce77b2a83dff599f829819d80d"></a><!-- doxytag: member="sph_types.h::SPH_BIG_FAST" ref="a566b63ce77b2a83dff599f829819d80d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_BIG_FAST</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro is defined if 32-bit words (and 64-bit words, if defined) can be read from and written to memory efficiently in big-endian convention. This is the case for little-endian platforms, and also for the little-endian platforms which have special big-endian access opcodes. </p>

</div>
</div>
<a class="anchor" id="add0ead78918ca1b3c98eefd65854b8fa"></a><!-- doxytag: member="sph_types.h::SPH_UPTR" ref="add0ead78918ca1b3c98eefd65854b8fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_UPTR</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>On some platforms, this macro is defined to an unsigned integer type into which pointer values may be cast. The resulting value can then be tested for being a multiple of 2, 4 or 8, indicating an aligned pointer for, respectively, 16-bit, 32-bit or 64-bit memory accesses. </p>

</div>
</div>
<a class="anchor" id="aea5170f5e2463294bb3c5858742c416b"></a><!-- doxytag: member="sph_types.h::SPH_UNALIGNED" ref="aea5170f5e2463294bb3c5858742c416b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPH_UNALIGNED</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>When defined, this macro indicates that unaligned memory accesses are possible with only a minor penalty, and thus should be prefered over strategies which first copy data to an aligned buffer. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a75df7959945379764b2993e32d7c5bcb"></a><!-- doxytag: member="sph_types.h::sph_u32" ref="a75df7959945379764b2993e32d7c5bcb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef __arch_dependant__ <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unsigned integer type whose length is at least 32 bits; on most architectures, it will have a width of exactly 32 bits. Unsigned C types implement arithmetics modulo a power of 2; use the <code><a class="el" href="sph__types_8h.html#a6b2da7fb1eca675723880c22fa7918ca">SPH_T32()</a></code> macro to ensure that the value is truncated to exactly 32 bits. Unless otherwise specified, all macros and functions which accept <code>sph_u32</code> values assume that these values fit on 32 bits, i.e. do not exceed 2^32-1, even on architectures where <code>sph_u32</code> is larger than that. </p>

</div>
</div>
<a class="anchor" id="a9096255be60de8b630c6d268461a0972"></a><!-- doxytag: member="sph_types.h::sph_s32" ref="a9096255be60de8b630c6d268461a0972" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef __arch_dependant__ <a class="el" href="sph__types_8h.html#a9096255be60de8b630c6d268461a0972">sph_s32</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Signed integer type corresponding to <code>sph_u32</code>; it has width 32 bits or more. </p>

</div>
</div>
<a class="anchor" id="ab8785020c236aac895d020a3367ef227"></a><!-- doxytag: member="sph_types.h::sph_u64" ref="ab8785020c236aac895d020a3367ef227" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef __arch_dependant__ <a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unsigned integer type whose length is at least 64 bits; on most architectures which feature such a type, it will have a width of exactly 64 bits. C99-compliant platform will have this type; it is also defined when the GNU compiler (gcc) is used, and on platforms where <code>unsigned long</code> is large enough. If this type is not available, then some hash functions which depends on a 64-bit type will not be available (most notably SHA-384, SHA-512, Tiger and WHIRLPOOL). </p>

</div>
</div>
<a class="anchor" id="ae48722d443535f1e82905e742f2b3d11"></a><!-- doxytag: member="sph_types.h::sph_s64" ref="ae48722d443535f1e82905e742f2b3d11" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef __arch_dependant__ <a class="el" href="sph__types_8h.html#ae48722d443535f1e82905e742f2b3d11">sph_s64</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Signed integer type corresponding to <code>sph_u64</code>; it has width 64 bits or more. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa21c79a8abd42546ea5862eca100acce"></a><!-- doxytag: member="sph_types.h::sph_bswap32" ref="aa21c79a8abd42546ea5862eca100acce" args="(sph_u32 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> sph_bswap32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Byte-swap a 32-bit word (i.e. <code>0x12345678</code> becomes <code>0x78563412</code>). This is an inline function which resorts to inline assembly on some platforms, for better performance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the 32-bit value to byte-swap </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the byte-swapped value </dd></dl>

</div>
</div>
<a class="anchor" id="a9fe9a72d55ebe6b5f47925a631eb5030"></a><!-- doxytag: member="sph_types.h::sph_bswap64" ref="a9fe9a72d55ebe6b5f47925a631eb5030" args="(sph_u64 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a> sph_bswap64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Byte-swap a 64-bit word. This is an inline function which resorts to inline assembly on some platforms, for better performance. This function is defined only if a suitable 64-bit type was found for <code>sph_u64</code></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the 64-bit value to byte-swap </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the byte-swapped value </dd></dl>

</div>
</div>
<a class="anchor" id="a7f729a6c8b9ead5cb2b0835aeae3217d"></a><!-- doxytag: member="sph_types.h::sph_dec16le" ref="a7f729a6c8b9ead5cb2b0835aeae3217d" args="(const void *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned sph_dec16le </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decode a 16-bit unsigned value from memory, in little-endian convention (least significant byte comes first).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the source address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the decoded value </dd></dl>

</div>
</div>
<a class="anchor" id="a6107a9b15c1ba89e5b37e1bb728ad654"></a><!-- doxytag: member="sph_types.h::sph_enc16le" ref="a6107a9b15c1ba89e5b37e1bb728ad654" args="(void *dst, unsigned val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sph_enc16le </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Encode a 16-bit unsigned value into memory, in little-endian convention (least significant byte comes first).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination buffer </td></tr>
    <tr><td class="paramname">val</td><td>the value to encode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19d8b62deef02aac1b42b6606e5eabd4"></a><!-- doxytag: member="sph_types.h::sph_dec16be" ref="a19d8b62deef02aac1b42b6606e5eabd4" args="(const void *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned sph_dec16be </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decode a 16-bit unsigned value from memory, in big-endian convention (most significant byte comes first).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the source address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the decoded value </dd></dl>

</div>
</div>
<a class="anchor" id="ae84619401c2338dd568d7466e2000279"></a><!-- doxytag: member="sph_types.h::sph_enc16be" ref="ae84619401c2338dd568d7466e2000279" args="(void *dst, unsigned val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sph_enc16be </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Encode a 16-bit unsigned value into memory, in big-endian convention (most significant byte comes first).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination buffer </td></tr>
    <tr><td class="paramname">val</td><td>the value to encode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3eeb6346fffa1029a239fe94bfdc4e6"></a><!-- doxytag: member="sph_types.h::sph_dec32le" ref="ad3eeb6346fffa1029a239fe94bfdc4e6" args="(const void *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> sph_dec32le </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decode a 32-bit unsigned value from memory, in little-endian convention (least significant byte comes first).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the source address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the decoded value </dd></dl>

</div>
</div>
<a class="anchor" id="ac808629acbf32dba42e5259b40983528"></a><!-- doxytag: member="sph_types.h::sph_dec32le_aligned" ref="ac808629acbf32dba42e5259b40983528" args="(const void *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> sph_dec32le_aligned </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decode a 32-bit unsigned value from memory, in little-endian convention (least significant byte comes first). This function assumes that the source address is suitably aligned for a direct access, if the platform supports such things; it can thus be marginally faster than the generic <code><a class="el" href="sph__types_8h.html#ad3eeb6346fffa1029a239fe94bfdc4e6">sph_dec32le()</a></code> function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the source address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the decoded value </dd></dl>

</div>
</div>
<a class="anchor" id="ac1eaa2034411e7619613a70a3813d074"></a><!-- doxytag: member="sph_types.h::sph_enc32le" ref="ac1eaa2034411e7619613a70a3813d074" args="(void *dst, sph_u32 val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sph_enc32le </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Encode a 32-bit unsigned value into memory, in little-endian convention (least significant byte comes first).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination buffer </td></tr>
    <tr><td class="paramname">val</td><td>the value to encode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77c96bbda2549c001f7807a035cf4d42"></a><!-- doxytag: member="sph_types.h::sph_enc32le_aligned" ref="a77c96bbda2549c001f7807a035cf4d42" args="(void *dst, sph_u32 val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sph_enc32le_aligned </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Encode a 32-bit unsigned value into memory, in little-endian convention (least significant byte comes first). This function assumes that the destination address is suitably aligned for a direct access, if the platform supports such things; it can thus be marginally faster than the generic <code><a class="el" href="sph__types_8h.html#ac1eaa2034411e7619613a70a3813d074">sph_enc32le()</a></code> function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination buffer </td></tr>
    <tr><td class="paramname">val</td><td>the value to encode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0334b8b7e706679f1e6588305eb194df"></a><!-- doxytag: member="sph_types.h::sph_dec32be" ref="a0334b8b7e706679f1e6588305eb194df" args="(const void *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> sph_dec32be </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decode a 32-bit unsigned value from memory, in big-endian convention (most significant byte comes first).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the source address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the decoded value </dd></dl>

</div>
</div>
<a class="anchor" id="a1dbf6ceed8e6a9bf198ad5e759b62d54"></a><!-- doxytag: member="sph_types.h::sph_dec32be_aligned" ref="a1dbf6ceed8e6a9bf198ad5e759b62d54" args="(const void *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a> sph_dec32be_aligned </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decode a 32-bit unsigned value from memory, in big-endian convention (most significant byte comes first). This function assumes that the source address is suitably aligned for a direct access, if the platform supports such things; it can thus be marginally faster than the generic <code><a class="el" href="sph__types_8h.html#a0334b8b7e706679f1e6588305eb194df">sph_dec32be()</a></code> function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the source address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the decoded value </dd></dl>

</div>
</div>
<a class="anchor" id="a15f055c4bbfa9f4c296c2b41fd163ba1"></a><!-- doxytag: member="sph_types.h::sph_enc32be" ref="a15f055c4bbfa9f4c296c2b41fd163ba1" args="(void *dst, sph_u32 val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sph_enc32be </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Encode a 32-bit unsigned value into memory, in big-endian convention (most significant byte comes first).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination buffer </td></tr>
    <tr><td class="paramname">val</td><td>the value to encode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e05e0b98da9cc62523d171bbbffd04e"></a><!-- doxytag: member="sph_types.h::sph_enc32be_aligned" ref="a8e05e0b98da9cc62523d171bbbffd04e" args="(void *dst, sph_u32 val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sph_enc32be_aligned </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sph__types_8h.html#a75df7959945379764b2993e32d7c5bcb">sph_u32</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Encode a 32-bit unsigned value into memory, in big-endian convention (most significant byte comes first). This function assumes that the destination address is suitably aligned for a direct access, if the platform supports such things; it can thus be marginally faster than the generic <code><a class="el" href="sph__types_8h.html#a15f055c4bbfa9f4c296c2b41fd163ba1">sph_enc32be()</a></code> function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination buffer </td></tr>
    <tr><td class="paramname">val</td><td>the value to encode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacbb6c4e2857cbe072efc28668e4235b"></a><!-- doxytag: member="sph_types.h::sph_dec64le" ref="aacbb6c4e2857cbe072efc28668e4235b" args="(const void *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a> sph_dec64le </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decode a 64-bit unsigned value from memory, in little-endian convention (least significant byte comes first). This function is defined only if a suitable 64-bit type was detected and used for <code>sph_u64</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the source address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the decoded value </dd></dl>

</div>
</div>
<a class="anchor" id="ab622d8132749d2030f11d805a381cf24"></a><!-- doxytag: member="sph_types.h::sph_dec64le_aligned" ref="ab622d8132749d2030f11d805a381cf24" args="(const void *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a> sph_dec64le_aligned </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decode a 64-bit unsigned value from memory, in little-endian convention (least significant byte comes first). This function assumes that the source address is suitably aligned for a direct access, if the platform supports such things; it can thus be marginally faster than the generic <code><a class="el" href="sph__types_8h.html#aacbb6c4e2857cbe072efc28668e4235b">sph_dec64le()</a></code> function. This function is defined only if a suitable 64-bit type was detected and used for <code>sph_u64</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the source address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the decoded value </dd></dl>

</div>
</div>
<a class="anchor" id="ad941f3fa0312fe430d675595c9f56444"></a><!-- doxytag: member="sph_types.h::sph_enc64le" ref="ad941f3fa0312fe430d675595c9f56444" args="(void *dst, sph_u64 val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sph_enc64le </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Encode a 64-bit unsigned value into memory, in little-endian convention (least significant byte comes first). This function is defined only if a suitable 64-bit type was detected and used for <code>sph_u64</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination buffer </td></tr>
    <tr><td class="paramname">val</td><td>the value to encode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18be3c60bf0074d44a241a4671af81fc"></a><!-- doxytag: member="sph_types.h::sph_enc64le_aligned" ref="a18be3c60bf0074d44a241a4671af81fc" args="(void *dst, sph_u64 val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sph_enc64le_aligned </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Encode a 64-bit unsigned value into memory, in little-endian convention (least significant byte comes first). This function assumes that the destination address is suitably aligned for a direct access, if the platform supports such things; it can thus be marginally faster than the generic <code><a class="el" href="sph__types_8h.html#ad941f3fa0312fe430d675595c9f56444">sph_enc64le()</a></code> function. This function is defined only if a suitable 64-bit type was detected and used for <code>sph_u64</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination buffer </td></tr>
    <tr><td class="paramname">val</td><td>the value to encode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26b1954cb1e2377c8aee81cb03446f8b"></a><!-- doxytag: member="sph_types.h::sph_dec64be" ref="a26b1954cb1e2377c8aee81cb03446f8b" args="(const void *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a> sph_dec64be </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decode a 64-bit unsigned value from memory, in big-endian convention (most significant byte comes first). This function is defined only if a suitable 64-bit type was detected and used for <code>sph_u64</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the source address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the decoded value </dd></dl>

</div>
</div>
<a class="anchor" id="a46484fd5d8c4780edca4b4e4df05f95b"></a><!-- doxytag: member="sph_types.h::sph_dec64be_aligned" ref="a46484fd5d8c4780edca4b4e4df05f95b" args="(const void *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a> sph_dec64be_aligned </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decode a 64-bit unsigned value from memory, in big-endian convention (most significant byte comes first). This function assumes that the source address is suitably aligned for a direct access, if the platform supports such things; it can thus be marginally faster than the generic <code><a class="el" href="sph__types_8h.html#a26b1954cb1e2377c8aee81cb03446f8b">sph_dec64be()</a></code> function. This function is defined only if a suitable 64-bit type was detected and used for <code>sph_u64</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the source address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the decoded value </dd></dl>

</div>
</div>
<a class="anchor" id="a690d29ac8e29c8d0c09d72914bf120d2"></a><!-- doxytag: member="sph_types.h::sph_enc64be" ref="a690d29ac8e29c8d0c09d72914bf120d2" args="(void *dst, sph_u64 val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sph_enc64be </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Encode a 64-bit unsigned value into memory, in big-endian convention (most significant byte comes first). This function is defined only if a suitable 64-bit type was detected and used for <code>sph_u64</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination buffer </td></tr>
    <tr><td class="paramname">val</td><td>the value to encode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6ea69fade68ec76765ac37f379787d2"></a><!-- doxytag: member="sph_types.h::sph_enc64be_aligned" ref="ac6ea69fade68ec76765ac37f379787d2" args="(void *dst, sph_u64 val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void sph_enc64be_aligned </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sph__types_8h.html#ab8785020c236aac895d020a3367ef227">sph_u64</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Encode a 64-bit unsigned value into memory, in big-endian convention (most significant byte comes first). This function assumes that the destination address is suitably aligned for a direct access, if the platform supports such things; it can thus be marginally faster than the generic <code><a class="el" href="sph__types_8h.html#a690d29ac8e29c8d0c09d72914bf120d2">sph_enc64be()</a></code> function. This function is defined only if a suitable 64-bit type was detected and used for <code>sph_u64</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>the destination buffer </td></tr>
    <tr><td class="paramname">val</td><td>the value to encode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Jul 20 2011 21:15:30 for sphlib by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
